import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Wallet Usage

## Initialize

<Tabs groupId="platform">
<TabItem value="js" label="JS">

Initialize client as a controller using [your project id](/2.0/introduction/cloud#project-id).

```js
const signClient = await SignClient.init({
  projectId: "<YOUR PROJECT ID>",
  // optional parameters
  relayUrl: "<YOUR RELAY URL>",
  metadata: {
    name: "Wallet name",
    description: "A short description for your wallet",
    url: "<YOUR WALLET'S URL>",
    icons: ["<URL TO WALLET'S LOGO/ICON>"],
  },
});
```


</TabItem>
<TabItem value="swift" label="Swift">

Create an AppMetadata object. It will describe your application and define its appearance in a web browser.
Then configure `Sign` instance with a metadata object you have instantiated.


```swift
let metadata = AppMetadata(name: <String>,
                           description: <String>,
                           url: <String>,
                           icons: <[String]>)

Sign.configure(metadata: <AppMetadata>)
```

### Subscribe for Sign publishers
When your `Sign` instance receives requests from a peer it will publish related event. So you should set subscription to handle them.

```swift
Sign.instance.sessionDeletePublisher
    .receive(on: DispatchQueue.main)
    .sink { [unowned self] _ in
        //handle event
    }.store(in: &publishers)
```

Following publishers are available to subscribe:

```swift
    public var sessionProposalPublisher: AnyPublisher<Session.Proposal, Never> 
    public var sessionRequestPublisher: AnyPublisher<Request, Never> 
    public var socketConnectionStatusPublisher: AnyPublisher<SocketConnectionStatus, Never> 
    public var sessionSettlePublisher: AnyPublisher<Session, Never> 
    public var sessionDeletePublisher: AnyPublisher<(String, Reason), Never> 
    public var sessionResponsePublisher: AnyPublisher<Response, Never> 
    public var sessionRejectionPublisher: AnyPublisher<(Session.Proposal, Reason), Never> 
    public var sessionUpdatePublisher: AnyPublisher<(sessionTopic: String, namespaces: [String : SessionNamespace]), Never>
    public var sessionEventPublisher: AnyPublisher<(event: Session.Event, sessionTopic: String, chainId: Blockchain?), Never> 
    public var sessionUpdateExpiryPublisher: AnyPublisher<(sessionTopic: String, expiry: Date), Never> 
```

</TabItem>
<TabItem value="kotlin" label="Kotlin">

```kotlin
val appMetaData = Sign.Model.AppMetaData(
    name = "Wallet Name",
    description = "Wallet Description",
    url = "Wallet Url",
    icons = listOfIconUrlStrings
)

val connectionType = Sign.ConnectionType.AUTOMATIC or Sign.ConnectionType.MANUAL

val init = Sign.Params.Init(
    application = application,
    relayServerUrl = /*websocket server with scheme, authority, and projectId as query parameter*/
    appMetaData = appMetaData,
    connectionType = connectionType
)

// or

val init = Sign.Params.Init(
    application = application,
    useTls = /*true or false*/,
    hostName = /*websocket server with scheme and authority*/,
    projectId = /*projectId*/,
    appMetaData = appMetaData,
    connectionType = connectionType
)

SignClient.initalize(init)
```

The wallet client will always be responsible for exposing accounts (CAPI10 compatible) to a Dapp and therefore is also in charge of signing.
To initialize the Sign client, create a `Sign.Params.Init` object in the Android Application class. The Init object will need the
application class, the Project ID, and the apps's AppMetaData. The `Sign.Params.Init` object will then be passed to the `SignClient`
initialize function. `Sign.Params.Init` also allows for custom URLs by passing URL string into the `hostName` property.

We allow developers to choose between the `Sign.ConnectionType.MANUAL` and `Sign.ConnectionType.AUTOMATIC`connection type. The default
one(`Sign.ConnectionType.AUTOMATIC`) disconnects wss connection when app enters background and reconnects when app is brought back to the
foreground. The `Sign.ConnectionType.MANUAL` allows developers to control when to open WebSocket connection and when to close it.
Accordingly, `SignClient.WebSocket.open()` and `SignClient.WebSocket.close()`.

Above, there are two example on how to create the initalizing parameters.

</TabItem>
</Tabs>




