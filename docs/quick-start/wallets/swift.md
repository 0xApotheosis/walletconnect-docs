---
description: Quick Start For Wallets Using Swift Client (iOS)
---

# Swift Client (iOS)

Swift implementation of WalletConnect v.2 protocol for native iOS applications.

:::caution
Note: The Swift client is in Beta and should only be used for testing.
:::


## Getting started with wallet integration

### Set up a project
In order to connect to WalletConnect Cloud, you need to create a new project first:
1. Go to https://cloud.walletconnect.com/app
2. Tap New Project
3. Give it a name and tap Create button
4. Your new project should appear on the projects list
5. You should see a project ID string if you tap on your project.
for more info on Project ID look at [Project ID](../../api/project-id.md).

### Add SDK for your project.
You can add a WalletConnect SDK to your project with Swift Package Manager. In order to do that:
1. Open XCode
2. Go to File -> Add Packages
3. Paste the repo GitHub url: https://github.com/WalletConnect/WalletConnectSwiftV2
4. Tap Add Package

### Instantiate a client
Create an AppMetadata object first. It will describe your application and define its appearance in a web browser.
Then create an instance of AuthClient, inject a metadata object you have instantiated, set a project ID generated when starting a project on WalletConnect Cloud. Set your client as a controller and provide a relayHost URL.

Note that you want to have only one instance of a client in your app, and you don’t want to deinitialize that instance.
```Swift
    let client: AuthClient = {
        let metadata = AppMetadata(
            name: "My Wallet",
            description: "description",
            url: "",
            icons: ["icon_url"])
        return AuthClient(
            metadata: metadata,
            projectId: "project_id",
            relayHost: "relay.walletconnect.com"
        )
    }()
```

##### Set client's delegate
Your View Controller or whatever place you have decided to initialize your client should conform to `AuthClientDelegate`.

```Swift
final class MyViewController: UIViewController, AuthClientDelegate {
    ...
    override func viewDidLoad() {
        super.viewDidLoad()
        client.delegate = self
    }
}
```
### Connect Clients
Your Wallet should allow users to scan a QR code generated by dapps. You are responsible for implementing it on your own.
For testing, you can use our test dapp at: https://react-app.walletconnect.com/, which is v2 protocol compliant.
Once you derive a URI from the QR code call `pair` method:

```Swift
try await client.pair(uri: uri)
```
if everything goes well, the following delegate method should be called
```Swift
func didReceive(sessionProposal: Session.Proposal) {
    
}
```
Session proposal is a heandshake sent by a dapp and it's puropose is to define a session rules. Heandshake procedure is defined by [CAIP-25](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-25.md).
`Session.Proposal` object conveys set of required `Namespaces` that contains required blockchains methods and events. Dapp requests with methods and wallet will emit events defined in namespaces. 

The user will either approve the session proposal (with session namespaces) or reject it. Session namespaces must at least contain requested methods, events and accounts associated with proposed blockchains.

Accounts must be provided according to [CAIP10](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-10.md) specification and be prefixed with a chain identifier. chain_id + : + account_address. You can find more on blockchain identifiers in [CAIP2](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md). Our `Account` type meets the criteria.
```
let account = Account("eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb")!
```

Accounts sent in session approval must at least match all requested blockchains.

Example proposal namespaces request:
```json
{
    "eip155":{
        "chains": ["eip155:137", "eip155:1"],
        "methods": ["eth_sign"],
        "events": ["accountsChanged"]
    },
    "cosmos":{
        "chains": ["cosmos:cosmoshub-4"],
        "methods": ["cosmos_signDirect"],
        "events": ["someCosmosEvent"]
    }
}
```

Example session namespaces response:
``` json
{
    "eip155":{
        "accounts": ["eip155:137:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb", "eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb"],
        "methods": ["eth_sign"],
        "events": ["accountsChanged"]
    },
    "cosmos":{
        "accounts": ["cosmos:cosmoshub-4:cosmos1t2uflqwqe0fsj0shcfkrvpukewcw40yjj6hdc0"],
        "methods": ["cosmos_signDirect", "personal_sign"],
        "events": ["someCosmosEvent", "proofFinalized"]
    }
}
```
```Swift
 client.approve(proposalId: "proposal_id", namespaces: [String: SessionNamespace])
```
When session is sucessfully approved another delegate method is called:
```Swift
func didSettle(session: Session) {
}
```
`Session` object represents an active session connection with a dapp. It contains dapp’s metadata (that you may want to use for displaying an active session to the user), namespaces, and expiry date. There is also a topic property that you will use for linking requests with related sessions.

You can always query settled sessions from the client later with:
```Swift
client.getSettledSessions()
```

### Handle requests from dapp
After the session is established, a dapp will request your wallet users to sign a transaction or a message. Requests will be delivered by the following delegate method.
```Swift
func didReceive(sessionRequest: Request) {
    
}
```
When a wallet receives a session request, you probably want to show it to the user. It’s method will be in scope of session namespaces. And it’s params are represented by `AnyCodable` type. An expected object can be derived as follows:

```Swift
        if sessionRequest.method == "personal_sign" {
            let params = try! sessionRequest.params.get([String].self)
        } else if method == "eth_signTypedData" {
            let params = try! sessionRequest.params.get([String].self)
        } else if method == "eth_sendTransaction" {
            let params = try! sessionRequest.params.get([EthereumTransaction].self)
        }
```

Now, your wallet (as it owns your user’s privete keys) is responsible for signing the transaction. After doing it, you can send a response to a dapp.

```Swift
let result = sign(request: sessionRequest) // implement your signing method
let response = JSONRPCResponse<AnyCodable>(id: sessionRequest.id, result: result)
client.respond(topic: sessionRequest.topic, response: .response(response))
```

### Update Session
If you want to update user session's chains, accounts, methods or events you can use session update method.

```Swift
try await client.update(topic: session.topic, namespaces: newNamespaces)
```

### Extend Session
By default, session lifetime is set for 7 days and after that time user's session will expire. But if you consider that a session should be extended you can call:

```Swift
try await client.extend(topic: session.topic)
```
above method will extend a user's session to a week.

### Disconnect Session
For good user experience your wallet should to allow users to disconnect unwanted sessions. In order to terminate a session use `disconnect` method.
```Swift
try await client.disconnect(topic: session.topic, reason: reason)
```
### Web Socket Connection
By default web socket connection is handled internally by the SDK. That means that Web socket will be safely disconnected when apps go to background and it will connect back when app reaches foreground. But if it is not expeted for your app and you want to handle socket connection manually you can do it as follows:

1. instantiate RelayClient object.  
```
let relayClient = RelayClient(
    relayHost: "relay.walletconnect.com",
    projectId: "52af113ee0c1e1a20xxx95730196c13e,
    socketConnectionType: .manual")
```  
2. inject RelayClient into AuthClient instance:  
```let client = AuthClient(metadata: metadata, relayClient: relayClient)```
3. control connection:  
```relayClient.connect()```

### Where to go from here
- Try our example wallet implementation that is part of WalletConnectSwiftV2 repository.
- To dive deeper into protocol concepts check out our [documentation](https://docs.walletconnect.com/2.0/protocol/glossary)
- Build API documentation in XCode: go to Product -> Build Documentation
